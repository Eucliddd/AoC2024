# day17
今天的题目在我这算very hard难度了，卡了一下午才写出来。
## puzzle1
模拟，没什么好说的
## puzzle2
一开始想沿着puzzle1的方法枚举A，但是发现要输出16个数字，A的范围是在[2^45, 2^48)，明显不可行。

通过观察输入，每一次循环都只会输出一个数字，而这个输出的数字和A当前的值（特别是低3位）有关，每一次循环都会把A向右移动3位。因此想到倒序遍历输出的值，每次求出A在进入这次循环时的值，当遍历到第一个输出时就求出了A的值。

具体的，分析下面的输入序列：
```
2,4,1,2,7,5,4,3,0,3,1,7,5,5,3,0

2 4: B = A % 8
1 2: B = B xor 2
7 5: C = A >> B
4 3: B = B xor C
0 3: A = A >> 3
1 7: B = B xor 7
5 5: print(B % 8)
3 0: JNZ A 
```
可以看到，每次输出的是B的低3位，而B初始化为A的低3位，所以只要枚举0-7作为A的低3位，A当前的值为上一轮的值左移3位加上这个枚举值，然后模拟计算B的值，如果最后B的值等于这轮要输出的值，那么这个枚举值就是A的低3位。

一开始只想到用贪心的方法求解，从0-7枚举低3位，如果有效则break，进入下一轮循环。但是发现贪心出来的当前的A值不一定能保证下一轮的A值也是正确的，所以就采用bfs去搜索了，好在剪枝的情况比较多，不然解空间有可能是2^48。